-- reference to the constants module
global_constants = require "main.constants"
global_stopped = false
global_completed = false
global_score = 0
global_level = 1
global_lifes = global_constants.MAX_LIFES

g_modes = {horizontal = 1, vertical = 2, popup = 3}
g_mode_active = 1

global_smiley_ids = { "60a", "60b", "60c", "60d", "60e", "60f", "61a", "61b","61c", "61d", "61e","61f", "62a", "62b", "62c", "62d", "62e", "62f"}
-- level settings
global_stage_smileys = {}
global_level_smileys_all = {}
global_level_smileys = {}
global_level_smileys_max = 5
global_level_time = 30

global_level_spawn_time = 0.0
global_level_spawn_time_vertical = 0.5
global_level_spawn_time_horizontal = 0.3
global_level_spawn_time_popup = 0.5

g_speed_horizontal_initial = 300
g_speed_horizontal = 0
g_horizontal_speed_up_factor = 15

g_speed_vertical_initial = 300
g_speed_vertical = 0
g_vertical_speed_up_factor = 15

g_popup_time = 2.2
g_popup_time_decrease_factor = 0.05
g_popup_time_min = 0.5

global_spawn_time_max_current_smiley = 6.0 -- max time for the current smiley to not being spawned
global_next_smiley_id = 1

go.property("level_smiley_count_max", 3)
go.property("single_score", 100)

function init(self)
	-- set background color
	-- msg.post("@render:", "clear_color", { color = vmath.vector4(0, 0, 0, 0) } )
	
	self.level_timer = global_level_time

	_init_moving_mode(self, g_modes.popup)
	
	_init_level(self, self.level_smiley_count_max)
	
	--  activate input
	msg.post(".", "acquire_input_focus")
end

function update(self, dt)
	if not global_stopped then
		self.level_timer = self.level_timer - dt
		self.level_timer = math.max(self.level_timer, 0)
		msg.post("/main#gui", "set_time", {time = self.level_timer})
		if self.level_timer <= 0 then
			self.level_timer = 0
			_process_game_over(self)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		
		if global_stopped == true then
			_restart(self)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("smiley_touched") then
		_process_smiley_touch(self, message.smiley_id)
	end
end

function _init_moving_mode(self, mode)
	-- set moving mode
	g_mode_active = mode
	print("Mode: " .. g_mode_active)

	-- set spawning time according to active game mode
	-- set moving speed
	if g_mode_active == g_modes.horizontal then
		global_level_spawn_time = global_level_spawn_time_horizontal
		g_speed_horizontal = g_speed_horizontal_initial + (global_level * g_horizontal_speed_up_factor)
		
	elseif g_mode_active == g_modes.vertical then
		global_level_spawn_time = global_level_spawn_time_vertical
		g_speed_vertical = g_speed_vertical_initial + (global_level * g_vertical_speed_up_factor)
		
	elseif g_mode_active == g_modes.popup then
		global_level_spawn_time = global_level_spawn_time_popup
		g_popup_time = g_popup_time - (global_level * g_popup_time_decrease_factor)
		if g_popup_time <= g_popup_time_min then g_popup_time = g_popup_time_min end
	end
	
	-- send defined spawn_time to smiley factory
	msg.post("/smiley_factory", "init_spawn_time", {spawn_time = global_level_spawn_time})
end

function _init_level(self, smiley_count)
	
	_init_moving_mode(self, 3) -- math.random(3)
	
	-- set stage smileys
	print ("Loading stage...")
	-- todo: add basic and unlocked smileys to stage
	global_stage_smileys = global_smiley_ids
	
	-- set all level smileys
	print ("Generating level...")
	global_level_smileys_all = {}
	for i = 1, global_level_smileys_max do
		local rand_type = 0
		repeat 
			-- get random index of stage smileys
			rand_type = math.random(tablelength(global_stage_smileys))
			-- check if smiley type already chosen.
			-- if this is the case, pick another rand_type
		until ( not tablecontains(global_level_smileys_all, global_stage_smileys[ rand_type ] ))
			
		-- add to level
		global_level_smileys_all[i] = global_stage_smileys[ rand_type ]
		print(global_level_smileys_all[i])
	end
	
	print ("Generating level smileys to pick...")
	global_level_smileys = {}
	for i = 1, smiley_count do
		-- get random index of id table
		local rand_type = math.random(tablelength(global_level_smileys_all))		
		-- add to level
		global_level_smileys[i] = global_level_smileys_all[ rand_type ]
		print(global_level_smileys[i])
	end
	print ("Generating level done.")
	
	-- set smileys on gui
	msg.post("/main#gui", "set_smileys", {
		smiley0 = global_level_smileys[1],
		smiley1 = global_level_smileys[2],
		smiley2 = global_level_smileys[3],
	})
	-- set first smiley index
	global_next_smiley_id = 1
	-- scale first smiley up
	msg.post("/main#gui", "activate_smiley", {nr = 1})
	-- set level text
	msg.post("/main#gui", "set_level", {level = global_level})
	-- reset timer
	self.level_timer = global_level_time
end

function _on_level_finished(self)
	print("Level finished!")
	global_level = global_level + 1
	msg.post("/main#gui", "show_ingame_gui", {show = false})
	msg.post("/main#gui", "show_dialog_level_complete", {show = true})
	global_stopped = true
	global_completed = true
end

function _process_smiley_touch(self, smiley_id)
	print("touched id: "..smiley_id)
	-- check if smiley is in table of level smileys
	if smiley_id == hash(global_level_smileys[ global_next_smiley_id ]) then
		print("Touched right one")
		-- add score
		global_score = global_score + self.single_score
		-- update gui
		msg.post("main#gui", "set_score", {amount = global_score})
		--activate next smiley
		if global_next_smiley_id < self.level_smiley_count_max  then
			global_next_smiley_id = global_next_smiley_id + 1
			msg.post("/main#gui", "activate_smiley", {nr = global_next_smiley_id})
		else
			_on_level_finished(self)
		end
		-- reset smiley factory timer
		msg.post("/smiley_factory", "reset_timer", {reset = true})
	else -- wrong smiley touched
		_decrease_lifes(self)
	end
end

function _process_game_over(self)
	print("Failed!")
	msg.post("/main#gui", "show_ingame_gui", {show = false})
	msg.post("/main#gui", "show_dialog_gameover", {show = true})
	global_stopped = true
end

function _restart(self)
	msg.post("/main#gui", "hide_all_dialogs")
	msg.post("/main#gui", "show_ingame_gui", {show = true})

	if not global_completed then
		global_score = 0
		global_lifes = global_constants.MAX_LIFES
		global_level = 1
		msg.post("main#gui", "set_score", {amount = global_score})
		msg.post("main#gui", "update_lifes", {lifes = global_lifes})
	else
		global_completed = false
	end
	
	_init_level(self, self.level_smiley_count_max)
	
	global_stopped = false
end

function _decrease_lifes(self)
	global_lifes = global_lifes - 1
	print("lifes: " ..  global_lifes)
	msg.post("/main#gui", "update_lifes", {lifes = global_lifes})
	if global_lifes < 0 then _process_game_over(self) end
end