-- reference to the constants module
g_constants = require "main.constants"
g_stopped = false
g_completed = false
g_score = 0
g_level = 1
g_start_level = 1
g_lifes = g_constants.MAX_LIFES
g_modes = {horizontal = 1, vertical = 2, popup = 3}
g_mode_active = 1
g_item_prob = 3
g_time_item_value = 3 -- seconds
g_smiley_ids = { "60a", "60b", "60c", "60d", "60e", "60f", "61a", "61b","61c", "61d", "61e","61f", "62a", "62b", "62c", "62d", "62e", "62f", "64a", "92a", "92b", "92d", "435", "600", "601", "602", "603", "604", "605", "606", "607", "609", "610", "611", "612", "613", "614", "615", "616", "617", "618", "619", "620", "622", "625", "626", "628", "629", "630", "632", "635", "636", "641", "642", "644", "648", "649"}
-- item emoticons
g_item_ids = {"u2764", "u23f2", "u1f0cf"} --  star:"u2b50"
g_item_table_ids = {} -- initialize in init function
g_emoji_heart_id = 1
g_emoji_time_id = 2
g_emoji_joker_id = 3
--g_emoji_star_id = 4

-- level settings
g_stage_smileys = {}
g_level_smileys_all = {}
g_level_smileys = {}
g_level_smileys_base = 6
g_level_smileys_max = g_level_smileys_base
g_level_time = 60
g_additional_time = 5

g_spawn_time_max_current_smiley = 4.0 -- max time for the current smiley to not being spawned
g_next_smiley_id = 1

g_game_over = false

go.property("level_smiley_count_max", 3)
go.property("single_score", 100)

local smileys_increase_step = 1

local g_level_spawn_time_base = 0.0
local level_spawn_time_min = 0.2
local g_level_spawn_time = 0.0
local g_level_spawn_time_vertical = 0.5
local g_level_spawn_time_horizontal = 0.5
local g_level_spawn_time_popup = 0.7
local g_level_spawn_time_decrease_step = 0.06

g_speed_horizontal = 0
local g_speed_horizontal_initial = 250
local g_speed_horizontal_max = 700
local g_horizontal_speed_up_factor = 20

g_speed_vertical = 0
local g_speed_vertical_initial = 220
local g_speed_vertical_max = 670
local g_vertical_speed_up_factor = 18

g_popup_time = 2.4
local g_popup_time_decrease_factor = 0.03
local g_popup_time_min = 1.0
local g_popup_spawn_increase_factor = 0.002

local lvl_begin_rotation = 5
local g_rotating_speed_decrease = 100
local g_rotating_spawntime_increase = 0.25

function init(self)
	-- set background color
	-- msg.post("@render:", "clear_color", { color = vmath.vector4(0, 0, 0, 0) } )

	-- don't start until main menu was touched
	g_stopped = true
	
	math.randomseed(os.time())
	math.random(); math.random(); math.random(); math.random(); math.random();
	-- init random numbers (https://forum.defold.com/t/lua-math-random-problem/19372)

	-- set timer to initial value
	self.level_timer = g_level_time
	self.level_smiley_count_max = 3
	_init_level(self, self.level_smiley_count_max)

	g_item_table_ids = get_table_ids( g_item_ids )
	
	--  activate input
	msg.post(".", "acquire_input_focus")

	-- show main menu
	msg.post("/main#gui", "show_dialog_main_menu", {show = true})
end

function update(self, dt)
	if not g_stopped then
		self.level_timer = self.level_timer - dt
		self.level_timer = math.max(self.level_timer, 0)
		-- show current time at gui
		msg.post("/main#gui", "set_time", {time = self.level_timer})
		-- if time runs out trigger game over
		if self.level_timer <= 0 then
			self.level_timer = 0
			_process_game_over(self)
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		-- if in game over state and screen was touched, show main menu
		if g_game_over == true then 
			msg.post("/main#gui", "show_dialog_main_menu", {show = true})
			g_game_over = false
			
		-- if in main menu and screen was touched, start game
		elseif g_stopped == true then
			_restart(self)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("smiley_touched") then
		_process_smiley_touch(self, message.smiley_id, sender)
	end
end

function _init_moving_mode(self)
	-- Methods for increasing difficulty:
	-- 	shwoing more smileys simultaneously: decrease g_level_spawn_time 
	-- 	decrease time  of showing each smiley: decrease g_speed_horizontal, g_speed_vertical, g_popup_time
	-- 	spawn more different smileys at one level (reduces propability of spawning the needed smiley): increase g_level_smileys_max
	
	-- set moving mode
	g_mode_active = math.random(3)
	print("Mode: " .. g_mode_active)
	
	-- set rotation
	local rotate = 0
	if g_level > lvl_begin_rotation and (math.random(2) == 1) then
		rotate = 1
	end
	print("Rotate: " .. rotate)
	
	-- set spawning time and moving speed according to active game mode and level
	-- If smileys are rotating, then slow down speed a bit
	if g_mode_active == g_modes.horizontal then
		g_level_spawn_time_base = g_level_spawn_time_horizontal
		g_speed_horizontal = g_speed_horizontal_initial + (g_level * g_horizontal_speed_up_factor)
		if g_speed_horizontal > g_speed_horizontal_max then g_speed_horizontal = g_speed_horizontal_max end
		if rotate == 1 then g_speed_horizontal = g_speed_horizontal - g_rotating_speed_decrease end
		
	elseif g_mode_active == g_modes.vertical then
		g_level_spawn_time_base = g_level_spawn_time_vertical
		g_speed_vertical = g_speed_vertical_initial + (g_level * g_vertical_speed_up_factor)
		if g_speed_vertical > g_speed_vertical_max then g_speed_vertical = g_speed_vertical_max end
		if rotate == 1 then g_speed_vertical = g_speed_vertical - g_rotating_speed_decrease end
		
	elseif g_mode_active == g_modes.popup then
		g_level_spawn_time_base = g_level_spawn_time_popup - (g_level * g_popup_spawn_increase_factor) 
		g_popup_time = g_popup_time - (g_level * g_popup_time_decrease_factor)
		if g_popup_time <= g_popup_time_min then g_popup_time = g_popup_time_min end
	end

	-- If smileys are rotating, then slow down spawning a bit
	if rotate == 1 then
		g_level_spawn_time_base = g_level_spawn_time_base + g_rotating_spawntime_increase
	end

	-- faster spawning every 5 level
	g_level_spawn_time = g_level_spawn_time_base - (math.floor(g_level / 5) * g_level_spawn_time_decrease_step)
	

	if g_level_spawn_time < level_spawn_time_min then g_level_spawn_time = level_spawn_time_min end

	-- increase amount of different smileys every 5 level
	g_level_smileys_max = g_level_smileys_base + (math.floor(g_level / 5) * smileys_increase_step)
	print("g_level_smileys_max: " ..g_level_smileys_max) 

	--debug
	print("g_level_spawn_time: " .. g_level_spawn_time)
	print("g_speed_horizontal: " .. g_speed_horizontal)
	print("g_speed_vertical: " .. g_speed_vertical)
	print("g_popup_time: " .. g_popup_time)
		
	-- send defined spawn_time and rotate-flag to smiley factory
	msg.post("/smiley_factory", "init_spawn_values", {spawn_time = g_level_spawn_time, rotating = rotate})
end

function _init_level(self, smiley_count)
	print("Level: " .. g_level)
	
	_init_moving_mode(self)
	
	-- set stage smileys
	print ("Loading stage...")
	-- todo: add basic and unlocked smileys to stage
	g_stage_smileys = g_smiley_ids
	
	-- set all level smileys
	print ("Generating level smileys...")
	g_level_smileys_all = {}
	for i = 1, g_level_smileys_max do
		local rand_type = 0
		repeat 
			-- get random index of stage smileys
			rand_type = math.random(tablelength(g_stage_smileys))
			-- check if smiley type already chosen.
			-- if this is the case, pick another rand_type
		until ( not tablecontains(g_level_smileys_all, g_stage_smileys[ rand_type ] ))
			
		-- add to level
		g_level_smileys_all[i] = g_stage_smileys[ rand_type ]
		print(g_level_smileys_all[i]) --debug
	end
	
	print ("Generating level smileys to pick...")
	g_level_smileys = {}
	for i = 1, smiley_count do
		-- get random index of id table
		local rand_type = math.random(tablelength(g_level_smileys_all))		
		-- add to level
		g_level_smileys[i] = g_level_smileys_all[ rand_type ]
		-- print(g_level_smileys[i]) --debug
	end
	print ("Generating level done.")
	
	-- set smileys on gui
	msg.post("/main#gui", "set_smileys", {
		smiley0 = g_level_smileys[1],
		smiley1 = g_level_smileys[2],
		smiley2 = g_level_smileys[3],
	})
	-- set first smiley index
	g_next_smiley_id = 1
	-- scale first smiley up
	msg.post("/main#gui", "activate_smiley", {nr = 1})
	-- set level text
	msg.post("/main#gui", "set_level", {level = g_level})
end

function _on_level_finished(self)
	print("Level finished!")
	-- add score
	local level_score = 100 * g_level
	add_score(level_score)
	-- increase level
	g_level = g_level + 1
	-- add seconds to timer
	self.level_timer = self.level_timer + g_additional_time
	-- show gui
	msg.post("/main#gui", "show_ingame_gui", {show = false})
	msg.post("/main#gui", "show_dialog_level_complete", {show = true})
	g_stopped = true
	g_completed = true
end

function _process_smiley_touch(self, smiley_id, sender)
	print("touched id: "..smiley_id)
	-- check if smiley is in table of level smileys
	if smiley_id == hash(g_level_smileys[ g_next_smiley_id ]) then
		print("Touched right one")
		-- emit particles
		msg.post(sender, "smiley_touch_success", {success = true})
		-- set next smiley to touch
		_handle_next_smiley(self, self.level_smiley_count_max)
	-- else check if item was touched
	elseif not _touch_item(self, smiley_id, sender) then
	-- wrong smiley touched
		msg.post("/main#gui", "feedback_wrong_smiley", {})
		_increase_lifes(self, -1)
	end
end

function _handle_next_smiley(self, max_smileys)
	--activate next smiley
	if g_next_smiley_id < max_smileys  then
		g_next_smiley_id = g_next_smiley_id + 1
		msg.post("/main#gui", "activate_smiley", {nr = g_next_smiley_id})
	else
		_on_level_finished(self)
	end
	-- reset smiley factory timer
	msg.post("/smiley_factory", "reset_timer", {reset = true})
end

function _touch_item(self, smiley_id, sender)
	local touched = true
	local item_index = g_item_table_ids[ smiley_id ]
	print (item_index)
	
	if item_index == g_emoji_heart_id then
		_increase_lifes(self, 1)
		
	elseif item_index == g_emoji_joker_id then
		print("Joker item touched")
		-- emit particles
		msg.post(sender, "smiley_touch_success", {success = true})
		-- set next smiley to touch
		_handle_next_smiley(self, self.level_smiley_count_max)
		
	elseif item_index == g_emoji_time_id then
		print("Time item touched")
		-- add seconds to timer
		self.level_timer = self.level_timer + g_time_item_value
		
	--elseif item_index == g_emoji_star_id then
	--	print("Star item touched")
	
	elseif item_index == nil then
		touched = false
	end
	return touched
end

function _process_game_over(self)
	print("Failed!")
	msg.post("/main#gui", "show_ingame_gui", {show = false})
	msg.post("/main#gui", "show_dialog_gameover", {show = true})
	g_stopped = true
	g_game_over = true

	self.level_timer = g_level_time
end

function _restart(self)
	msg.post("/main#gui", "show_ingame_gui", {show = true})

	if not g_completed then
		g_score = 0
		g_lifes = g_constants.MAX_LIFES
		g_level = g_start_level
		msg.post("main#gui", "set_score", {amount = g_score})
		msg.post("main#gui", "update_lifes", {lifes = g_lifes})
	else
		g_completed = false
	end
	
	_init_level(self, self.level_smiley_count_max)
	
	g_stopped = false
end

function _increase_lifes(self, amount)
	g_lifes = g_lifes + amount
	print("lifes: " ..  g_lifes)
	msg.post("/main#gui", "update_lifes", {lifes = g_lifes})
	if g_lifes < 1 then 
		_process_game_over(self) 
	elseif g_lifes > g_constants.MAX_LIFES then
		g_lifes = g_constants.MAX_LIFES
	end
end

-- adds score and updates gui
function add_score(amount)
	g_score = g_score + amount
	-- update gui
	msg.post("main#gui", "set_score", {amount = g_score})
end

-- helper
function get_table_ids(table)
	local index={}
	for k,v in pairs(table) do
		index[ hash(v) ]=k
	end
	return index
end