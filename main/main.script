-- reference to the constants module
g_constants = require "main.constants"
g_screen_scale = 1.0
g_show_ads = true
g_sound_active = true
g_stopped = false
g_completed = false
g_pause = false
g_highscore_level = 1
g_score = 0
g_level = 1
g_start_level = 1
g_lifes = g_constants.MAX_LIFES
g_modes = {horizontal = 1, vertical = 2, popup = 3}
g_mode_active = 1
g_item_prob = 5
g_time_item_value = 5 -- seconds
g_smiley_ids = { "60a", "60b", "60c", "60d", "60e", "60f", "61a", "61b","61c", "61d", "61e","61f", "62a", "62b", "62c", "62d", "62e", "62f", "64a", "92a", "92b", "92d", "435", "600", "601", "602", "603", "604", "605", "606", "607", "609", "610", "611", "612", "613", "614", "615", "616", "617", "618", "619", "620", "622", "625", "626", "628", "629", "630", "632", "635", "636", "641", "642", "644", "648", "649"}
-- item emoticons
g_item_ids = {"u2764", "u23f2", "u1f0cf", "u2b50"} --  star:"u2b50"
g_item_table_ids = {} -- initialize in init function
g_emoji_heart_id = 1
g_emoji_time_id = 2
g_emoji_joker_id = 3
g_emoji_star_id = 4
g_smileys_success_ids = {"u1f60f", "u1f4aa", "u1f44c", "u1f44d", "u1f44f", "u1f60e", "u1f917", "u1f929", "u1f970", "u1f973"}
g_smileys_gameover_ids = {"u1f4a9", "u1f61e", "u1f61f", "u1f62b", "u1f62d", "u1f62e", "u1f92f", "u1f610", "u1f613", "u1f629", "u1f635", "u1f648", "u2639"}
g_stars = 0
g_stars_of_game = 0
g_continue_stars = 500
g_restarted = false
g_restarted_level = 1
g_background_count = 5
g_reset_counter = 1
g_reset_max = 3
g_show_ad_gameover = false

-- level settings
g_stage_smileys = {}
g_level_smileys_all = {}
g_level_smileys = {}
g_level_smileys_base = 6
g_level_smileys_max = g_level_smileys_base
g_level_time = 60
g_level_time_restart = 30
g_additional_time = 5

g_spawn_time_max_current_smiley = 3.5 -- max time for the current smiley to not being spawned
g_next_smiley_id = 1

g_game_over = false
g_main_menu = true

-- statistics
g_games_played = 0

go.property("level_smiley_count_max", 3)
go.property("single_score", 100)

local smileys_increase_step = 1

local g_level_spawn_time_base = 0.0
local level_spawn_time_min = 0.2
local g_level_spawn_time = 0.0
local g_level_spawn_time_vertical = 0.5
local g_level_spawn_time_horizontal = 0.5
local g_level_spawn_time_popup = 0.7
local g_level_spawn_time_decrease_step = 0.06

g_speed_horizontal = 0
local g_speed_horizontal_initial = 250
local g_speed_horizontal_max = 700
local g_horizontal_speed_up_factor = 17

g_speed_vertical = 0
local g_speed_vertical_initial = 220
local g_speed_vertical_max = 670
local g_vertical_speed_up_factor = 15

g_popup_time = 0
g_popup_time_base = 2.4
local g_popup_time_decrease_factor = 0.03
local g_popup_time_min = 1.0
local g_popup_spawn_increase_factor = 0.002

local lvl_begin_rotation = 5
local g_rotating_speed_decrease = 100
local g_rotating_spawntime_increase = 0.1

function init(self)
	-- set background color
	-- msg.post("@render:", "clear_color", { color = vmath.vector4(0, 0, 0, 0) } )

	--g_screen_scale = tonumber(sys.get_config("display.height")) / g_constants.SCREEN_HEIGHT
	--print(g_screen_scale)

	window.set_listener(window_listener)
	
	-- load savegame
	_load_savegame()
	
	-- don't start until main menu was touched
	g_stopped = true
	
	math.randomseed(os.time())
	math.random(); math.random(); math.random(); math.random(); math.random();
	-- init random numbers (https://forum.defold.com/t/lua-math-random-problem/19372)

	-- set timer to initial value
	self.level_timer = g_level_time
	self.level_smiley_count_max = 3
	self.second = 0.0
	--_init_level(self, self.level_smiley_count_max)

	g_item_table_ids = get_table_ids( g_item_ids )
	
	--  activate input
	msg.post(".", "acquire_input_focus")

	-- show main menu
	msg.post("/main#gui", "show_dialog_main_menu", {show = true})
end

function window_listener(self, constant, data)
	if constant == window.WINDOW_EVENT_FOCUS_LOST then
		if not g_stopped and not g_pause then
			print("Window lost focus. Pausing game.")
			msg.post("main#gui", "toggle_pause")
		end
	end
end

function update(self, dt)
	if not g_stopped and not g_pause then
		self.level_timer = self.level_timer - dt
		self.level_timer = math.max(self.level_timer, 0)
		self.second = self.second + dt 
		if self.second >= 1.0 then
			self.second = 0.0
			-- show current time at gui
			local scale_up = 0
			if self.level_timer <= 10 then scale_up = 1 end
			msg.post("/main#gui", "set_time", {time = self.level_timer, scale = scale_up})
		end
		-- if time runs out trigger game over
		if self.level_timer <= 0 then
			self.level_timer = 0
			_process_game_over(self)
		end
	end
end

function on_input(self, action_id, action)
	--input in main.gui_script!
end

function on_message(self, message_id, message, sender)
	if message_id == hash("smiley_touched") then
		_process_smiley_touch(self, message.smiley_id, sender)
	elseif message_id == hash("restart") then
		_restart(self)
	elseif message_id == hash("reset") then
		_reset(self)
	elseif message_id == hash("next_level") then
		_start_next_level(self)
	elseif message_id == hash("continue_level") then
		if not g_restarted and g_stars >= g_continue_stars then
			_restart_from_current_level(self)
		end
	elseif message_id == hash("pause") then
		_handle_pause()
	end
end

function _init_moving_mode(self)
	-- Methods for increasing difficulty:
	-- 	shwoing more smileys simultaneously: decrease g_level_spawn_time 
	-- 	decrease time  of showing each smiley: decrease g_speed_horizontal, g_speed_vertical, g_popup_time
	-- 	spawn more different smileys at one level (reduces propability of spawning the needed smiley): increase g_level_smileys_max
	
	-- set moving mode
	g_mode_active = math.random(3)
	print("Mode: " .. g_mode_active)
	
	-- set rotation
	local rotate = 0
	if g_level > lvl_begin_rotation and (math.random(2) == 1) then
		rotate = 1
	end
	print("Rotate: " .. rotate)
	
	-- set spawning time and moving speed according to active game mode and level
	-- If smileys are rotating, then slow down speed a bit
	if g_mode_active == g_modes.horizontal then
		g_level_spawn_time_base = g_level_spawn_time_horizontal
		g_speed_horizontal = g_speed_horizontal_initial + (g_level * g_horizontal_speed_up_factor)
		if g_speed_horizontal > g_speed_horizontal_max then g_speed_horizontal = g_speed_horizontal_max end
		if rotate == 1 then g_speed_horizontal = g_speed_horizontal - g_rotating_speed_decrease end
		
	elseif g_mode_active == g_modes.vertical then
		g_level_spawn_time_base = g_level_spawn_time_vertical
		g_speed_vertical = g_speed_vertical_initial + (g_level * g_vertical_speed_up_factor)
		if g_speed_vertical > g_speed_vertical_max then g_speed_vertical = g_speed_vertical_max end
		if rotate == 1 then g_speed_vertical = g_speed_vertical - g_rotating_speed_decrease end
		
	elseif g_mode_active == g_modes.popup then
		g_level_spawn_time_base = g_level_spawn_time_popup - (g_level * g_popup_spawn_increase_factor) 
		g_popup_time = g_popup_time_base - (g_level * g_popup_time_decrease_factor)
		if g_popup_time <= g_popup_time_min then g_popup_time = g_popup_time_min end
	end

	-- If smileys are rotating, then slow down spawning a bit
	if rotate == 1 then
		g_level_spawn_time_base = g_level_spawn_time_base + g_rotating_spawntime_increase
	end

	-- faster spawning every 5 level
	g_level_spawn_time = g_level_spawn_time_base - (math.floor(g_level / 5) * g_level_spawn_time_decrease_step)
	

	if g_level_spawn_time < level_spawn_time_min then g_level_spawn_time = level_spawn_time_min end

	-- increase amount of different smileys every 5 level
	g_level_smileys_max = g_level_smileys_base + (math.floor(g_level / 5) * smileys_increase_step)
	print("g_level_smileys_max: " ..g_level_smileys_max) 

	--debug
	print("g_level_spawn_time: " .. g_level_spawn_time)
	print("g_speed_horizontal: " .. g_speed_horizontal)
	print("g_speed_vertical: " .. g_speed_vertical)
	print("g_popup_time: " .. g_popup_time)
		
	-- send defined spawn_time and rotate-flag to smiley factory
	msg.post("/smiley_factory", "init_spawn_values", {spawn_time = g_level_spawn_time, rotating = rotate})
end

function _init_level(self, smiley_count)
	print("Level: " .. g_level)

	_set_background()
	
	_init_moving_mode(self)
	
	-- set stage smileys
	print ("Loading stage...")
	-- todo: add basic and unlocked smileys to stage
	g_stage_smileys = g_smiley_ids
	
	-- set all level smileys
	print ("Generating level smileys...")
	g_level_smileys_all = {}
	for i = 1, g_level_smileys_max do
		local rand_type = 0
		repeat 
			-- get random index of stage smileys
			rand_type = math.random(tablelength(g_stage_smileys))
			-- check if smiley type already chosen.
			-- if this is the case, pick another rand_type
		until ( not tablecontains(g_level_smileys_all, g_stage_smileys[ rand_type ] ))
			
		-- add to level
		g_level_smileys_all[i] = g_stage_smileys[ rand_type ]
		print(g_level_smileys_all[i]) --debug
	end
	
	print ("Generating level smileys to pick...")
	g_level_smileys = {}
	for i = 1, smiley_count do
		-- get random index of id table
		local rand_type = math.random(tablelength(g_level_smileys_all))		
		-- add to level
		g_level_smileys[i] = g_level_smileys_all[ rand_type ]
		-- print(g_level_smileys[i]) --debug
	end
	print ("Generating level done.")
	
	-- set smileys on gui
	msg.post("/main#gui", "set_smileys", {
		smiley0 = g_level_smileys[1],
		smiley1 = g_level_smileys[2],
		smiley2 = g_level_smileys[3],
	})
	-- set first smiley index
	g_next_smiley_id = 1
	-- scale first smiley up
	msg.post("/main#gui", "activate_smiley", {nr = 1})
	-- set level text
	msg.post("/main#gui", "set_level", {level = g_level})
	-- set lifes
	msg.post("/main#gui", "update_lifes", {lifes = g_lifes})
end

function _handle_next_smiley(self, max_smileys)
	--activate next smiley
	if g_next_smiley_id < max_smileys  then
		g_next_smiley_id = g_next_smiley_id + 1
		msg.post("/main#gui", "activate_smiley", {nr = g_next_smiley_id})
	else
		_on_level_complete(self)
	end
	-- reset smiley factory timer
	msg.post("/smiley_factory", "reset_timer", {reset = true})
end

function _process_smiley_touch(self, smiley_id, sender)
	print("touched id: "..smiley_id)
	
	-- check if smiley is in table of level smileys
	if smiley_id == hash(g_level_smileys[ g_next_smiley_id ]) then
		print("Touched right one")
		_play_sound_touched_smiley()
		-- emit particles
		msg.post(sender, "smiley_touch_success", {success = true})
		-- set next smiley to touch
		_handle_next_smiley(self, self.level_smiley_count_max)	
	-- else check if item was touched
	elseif not _touch_item(self, smiley_id, sender) then
		-- wrong smiley touched
		msg.post("/main#gui", "feedback_wrong_smiley", {})
		_increase_lifes(self, -1)
		_play_sound_touched_smiley()
		_play_sound_fail()
	end
end

function _touch_item(self, smiley_id, sender)
	local touched = true
	local item_index = g_item_table_ids[ smiley_id ]
	
	if item_index == g_emoji_heart_id then
		_increase_lifes(self, 1)
		
	elseif item_index == g_emoji_joker_id then
		-- set next smiley to touch
		_handle_next_smiley(self, self.level_smiley_count_max)
		
	elseif item_index == g_emoji_time_id then
		-- add seconds to timer
		self.level_timer = self.level_timer + g_time_item_value
		msg.post("/main#gui", "set_time", {time = self.level_timer, scale = 1})
		
	elseif item_index == g_emoji_star_id then
		_add_stars_amount(1)
	
	elseif item_index == nil then
		touched = false
	end

	if touched then 
		-- emit particles
		msg.post(sender, "smiley_touch_success", {success = true})
		-- play sound
		_play_sound_touched_item()
	end
	
	return touched
end

function _process_game_over(self)
	
	msg.post("/main#gui", "show_ingame_gui", {show = false})
	msg.post("/main#gui", "show_dialog_gameover", {show = true})
	g_stopped = true
	g_game_over = true

	_add_stars_game_finished()

	if g_level > 1 then 
		g_games_played = g_games_played + 1
	end

	if g_level > g_highscore_level then
		g_highscore_level = g_level
	end
	
	save_game()
	
	print_values(self) --debug
end

function _reset(self)
	g_score = 0
	g_lifes = g_constants.MAX_LIFES
	g_level = g_start_level
	g_restarted_level = 1
	g_stars_of_game = 0
	self.level_timer = g_level_time	
	g_restarted = false
	g_game_over = false
	g_completed = false
end

function _restart(self)
	_reset(self)
	
	msg.post("main#gui", "show_ingame_gui", {show = true})
	msg.post("main#gui", "set_time", {time = self.level_timer, scale = 1})
	
	_init_level(self, self.level_smiley_count_max)

	g_stopped = false
end

function _restart_from_current_level(self)
	g_stars = g_stars - g_continue_stars
	save_game()
	local lvl = g_level
	_reset(self)
	self.level_timer = g_level_time_restart	
	g_level = lvl
	g_restarted_level = lvl
	g_restarted = true
	_start_next_level(self)
end

function _start_next_level(self)
	-- could happen that lifes < 1 when wrong and right 
	-- smiley were touched simultaneously
	if g_lifes < 1 then
		_increase_lifes(self, 1)
	end

	msg.post("main#gui", "show_ingame_gui", {show = true})
	msg.post("main#gui", "set_time", {time = self.level_timer, scale = 1})
	
	_init_level(self, self.level_smiley_count_max)
	
	g_completed = false
	g_stopped = false
end

function _on_level_complete(self)
	if g_lifes > 0 then
		print("Level finished!")
		-- add score
		local level_score = 100 * g_level
		add_score(level_score)
		-- increase level
		g_level = g_level + 1
		-- add seconds to timer
		self.level_timer = self.level_timer + g_additional_time
		-- update gui time
		msg.post("/main#gui", "set_time", {time = self.level_timer, scale = 0})
		-- hide ingame gui
		msg.post("/main#gui", "show_ingame_gui", {show = false})
		-- show "level complete"
		msg.post("/main#gui", "show_dialog_level_complete", {show = true})
		-- set game state flags
		g_stopped = true
		g_completed = true

		_play_sound_complete()
	end
	--else level complete, but lifes = 0 (right and wrong smiley were touched simultaneously) -> game over
		
	print_values(self) --debug
end

function _handle_pause()
	
end

-- adds hearts to current game, and updates gui
-- if hearts <= 0 then game over
function _increase_lifes(self, amount)
	g_lifes = g_lifes + amount
	msg.post("/main#gui", "update_lifes", {lifes = g_lifes})
	if g_lifes < 1 then 
		_process_game_over(self) 
	elseif g_lifes > g_constants.MAX_LIFES then
		g_lifes = g_constants.MAX_LIFES
	end
	print("lifes: " ..  g_lifes)
end

-- adds score and updates gui
function add_score(amount)
	g_score = g_score + amount
	-- update gui
	msg.post("main#gui", "set_score", {amount = g_score})
end

-- Adds stars after gameover. 
-- For each level the amount according to the level number.
function _add_stars_game_finished()
	local amount = 0
	-- add stars for each level (1 star for level 1; 2 stars for level 2, ...)
	for var = g_restarted_level, g_level - 1, 1 do
		amount = amount + var
	end
	_add_stars_amount(amount)
end

-- adds a certain amount of stars to actual game
function _add_stars_amount(amount)
	print("Got Stars: " .. amount)
	g_stars_of_game = g_stars_of_game + amount
	g_stars = g_stars + g_stars_of_game
end

-- sets a random background
function _set_background()
	local background_prefix = "background_ingame_"
	local background_nr = math.random(g_background_count)
	msg.post("main#sprite_background", "play_animation", {id = hash(background_prefix .. tostring(background_nr))})
end

function save_game()
	local sound = 0
	if g_sound_active then sound = 1 end
	
	local save_table = {stars=g_stars, 
	games_played=g_games_played, 
	reset_counter=g_reset_counter, 
	sound_active=sound,
	highscore_level = g_highscore_level}
	
	local file_path = sys.get_save_file("Tapmoji", "save")
	if not sys.save(file_path, save_table) then
		-- Alert user that the data could not be saved
		print("Couldn't save progress!")
	else
		print("Saved game")
	end
end

function _load_savegame() 
	local file_path = sys.get_save_file("Tapmoji", "save")
	g_stars = sys.load(file_path).stars or 0
	g_games_played = sys.load(file_path).games_played or 0
	g_reset_counter = sys.load(file_path).reset_counter or 0
	g_highscore_level = sys.load(file_path).highscore_level or 0
	sound_active = sys.load(file_path).sound_active or 0
	
	g_sound_active = false
	if sound_active == 1 then g_sound_active = true end
		
	print("-- Loaded savegame: ")
	print("Stars: " .. g_stars)
	print("Games played: " .. g_games_played)
	print("Reset Counter: " .. g_reset_counter)
	print("Highscore level: " ..g_highscore_level)
	print("Sound active: " .. tostring(g_sound_active))
	print("--")
end

-- counts the amount of clicks on the "back to menu" button
-- triggers showing an interstitial ad when amount = g_reset_max
function increase_reset_counter()
	g_reset_counter = g_reset_counter + 1
	if g_reset_counter >= g_reset_max then 
		g_reset_counter = 0
		g_show_ad_gameover = true
	end
	save_game()
end

-- sounds

function play_music(play)
	local sound_path = "#music"
	sound.stop(sound_path)
	if play and g_sound_active then
		sound.play(sound_path)
	end
end

function _play_sound_touched_smiley()
	if g_sound_active then
		local sound_nr = math.random(4)
		sound.play("#sound_pop" .. tostring(sound_nr))
	end
end

function _play_sound_touched_item()
	if g_sound_active then
		sound.play("#sound_pop1")
		sound.play("#sound_item2", {delay = 0.15})
	end
end

function _play_sound_complete()
	if g_sound_active then
		sound.play("#sound_complete", {delay = 0.2})
	end
end

function _play_sound_gameover()
	if g_sound_active then
		sound.play("#sound_complete")
	end
end

function _play_sound_fail()
	if g_sound_active then
		sound.play("#sound_fail")
	end
end

function play_sound_count_stars(play)
	local sound_path = "#sound_stars"
	if play then
		if g_sound_active then
			sound.play(sound_path)
		end
	else
		sound.stop(sound_path)
	end
end

function _play_sound_button()
	if g_sound_active then
		sound.play("#sound_click1")
	end
end


-- helper
function get_table_ids(table)
	local index={}
	for k,v in pairs(table) do
		index[ hash(v) ]=k
	end
	return index
end

function print_values(self)
	print(" ----------------------" )
	print("Level: " .. g_level)
	print("Lifes: " .. g_lifes)
	print("Time remaining: " .. self.level_timer)
	print("Stars of game: " .. g_stars_of_game)
	print("Gameover: " .. tostring(g_game_over))
	print("Completed: " .. tostring(g_completed))
	print("Stopped: " .. tostring(g_stopped))
	print("Main Menu: " .. tostring(g_main_menu))
	print(" ----------------------" )
end